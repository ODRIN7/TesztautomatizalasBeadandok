<?xml version="1.0"?>
<doc>
<assembly>
<name>
Typemock.Isolator.VisualBasic
</name>
</assembly>
<members>
<member name="T:Typemock.Isolator.VisualBasic.My.Resources.Resources">
<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member>
<member name="P:Typemock.Isolator.VisualBasic.My.Resources.Resources.ResourceManager">
<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member>
<member name="P:Typemock.Isolator.VisualBasic.My.Resources.Resources.Culture">
<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member>
<member name="T:Typemock.Isolator.VisualBasic.IsolateVB">
 <summary>
 This module is the entry point to the Typemock Isolator Visual Basic Arrange-Act-Assert API. It is used to create fake objects,
 fake shared method behavior, define behavior of future instances and more.
 </summary>
</member>
<member name="T:Typemock.Isolator.VisualBasic.IsolateVB.Members">
 <summary>
 A behavior setting on how the fake object is created. 
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.MustSpecifyReturnValues">
 <summary>
 All void calls are ignored. Unless an alternate behavior is set (using <see cref="T:Typemock.Isolator.VisualBasic.TheseCalls"/>) for functions that return values and property getters, 
 they will throw a <see cref="T:TypeMock.TypeMockException"/> when they are called.
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.CallOriginal">
 <summary>
 The original implementation of all methods will be used, unless changed using <see cref="T:Typemock.Isolator.VisualBasic.TheseCalls"/>.
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnNulls">
 <summary>
 All void calls are ignored. Unless using <see cref="T:Typemock.Isolator.VisualBasic.TheseCalls"/> on methods that return values and properties, 
 they will return Nothing (or zero for value types). 
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnRecursiveFakes">
 <summary>
 <c>Default</c>. All void calls are ignored. When calling the fake's methods returning values or properties, 
 they will return a fake value, which presents this behavior recursively. Any deep call will never return Nothing. 
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.MustBeSpecified">
 <summary>
 All method behaviors must be define or calling them will throw a <see cref="T:TypeMock.TypeMockException"/>.
 </summary>
</member>
<member name="T:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe">
 <summary>
  A behavior setting on how the fake object is created.
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe.Ignored">
 <summary>
  Don't execute constructor when creating a fake object
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe.Called">
 <summary>
  Run constructor when creating a fake object
 </summary>
</member>
<member name="T:Typemock.Isolator.VisualBasic.IsolateVB.BaseConstructorWillBe">
 <summary>
 A behavior setting on how the base object's constructor behaves
 </summary>
</member>
<member name="F:Typemock.Isolator.VisualBasic.IsolateVB.BaseConstructorWillBe.Ignored">
 <summary>
 Don't execute base constructor when creating a fake object.
 </summary>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members)"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members)">
 <summary>
 Returns a fake instance of type T.
 </summary>
 <typeparam name="T">The type of fake object to create.</typeparam>
 <param name="behavior">The default behavior the fake object will use; see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.Members"/> for possible values.</param>
 <returns>A fake instance of Type T.</returns>
 <example>
 The following test shows creating a fake instance with the default value of <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnRecursiveFakes"/>:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_UseDefault()
    ' Create a fake object which will return recursive fakes
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
 
    ' This fake object will now return zero or equivalent to methods returning value types
    Assert.AreEqual(0, fake.CountLines)
 
    ' It will return recursive fakes for functions returning reference types, so deep calls
    ' will not return null values
    Assert.IsNotNull(fake.LogFile.ContainingFolder)
 End Sub
 </code>
 The next test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.CallOriginal"/> to create a fake object that will behave 
 identically to a normal object, but can still have its behavior modified or asserted against:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_CallOriginal
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)
 
    fake.LineCount = 0
    ' The following call is not faked so the original implementation will be executed
    fake.Write("Hello")
 
    Assert.AreEqual(1, fake.LineCount)
 End Sub 
 </code>
 The next test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnNulls"/> to create a fake object that will return null values
 (Nothing) for any function returning a reference type, and 0 or equivalent for functions returning a value type:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_ReturnNulls()
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.ReturnNulls)
 
    ' The fake object will return Nothing for any call returning a reference type
    Assert.IsNull(fake.LogFile)
    ' It will return 0 for any calls returning a value type
    Assert.AreEqual(0, fake.LineCount)
 End Sub
 </code>
 The final test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.MustSpecifyReturnValues"/> to ruturn a fake object that will 
 throw an exception if no behavior is set on a function it called:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_MustSpecifyReturnValues()
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.MustSpecifyReturnValues)
 
    ' the following call does not return a value so it is simply ignored
    fake.Increment()
 
    ' the following call did not have its behavior set so it will throw when called
    fake.GetFile()
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members,Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe)">
 <summary>
 Returns a fake instance of type T.
 </summary>
 <typeparam name="T">The type of fake object to create.</typeparam>
 <param name="behavior">The default behavior the fake object will use, see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.Members"/> for possible values.</param>
 <param name="constructorBehavior">Declare if the class constructor should execute, see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe"/> for possible values.</param>
 <returns>A fake instance of Type T.</returns>
 <example>
 The following test shows creating a fake instance with the default value of <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnRecursiveFakes"/>:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_UseDefault()
    ' Create a fake object which will return recursive fakes but call the class constructor
    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.ReturnRecursiveFakes, ConstructorWillBe.Called)
 
    ' This fake object will now return zero or equivalent to methods returning value types
    Assert.AreEqual(0, fake.CountLines)
 
    ' It will return recursive fakes for functions returning reference types, so deep calls
    ' will not return null values
    Assert.IsNotNull(fake.LogFile.ContainingFolder)
 End Sub
 </code>
 The next test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.CallOriginal"/> to create a fake object that will behave 
 identically to a normal object, but can still have its behavior modified or asserted against:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_CallOriginal
    ' Create a fake object using call original but don't invoke its constructor
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal, ConstructorWillBe.Ignored)
 
    fake.LineCount = 0
    ' The following call is not faked so the original implementation will be executed
    fake.Write("Hello")
 
    Assert.AreEqual(1, fake.LineCount)
 End Sub 
 </code>
 The next test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnNulls"/> to create a fake object that will return null values
 (Nothing) for any function returning a reference type, and 0 or equivalent for functions returning a value type:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_ReturnNulls()
    ' Create a fake object without invoking the class constructor
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.ReturnNulls, ConstructorWillBe.Ignored)
 
    ' The fake object will return Nothing for any call returning a reference type
    Assert.IsNull(fake.LogFile)
    ' It will return 0 for any calls returning a value type
    Assert.AreEqual(0, fake.LineCount)
 End Sub
 </code>
 The final test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.MustSpecifyReturnValues"/> to ruturn a fake object that will 
 throw an exception if no behavior is set on a function it called:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_MustSpecifyReturnValues()
    ' Create a fake object without invoking the class constructor
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.MustSpecifyReturnValues, ConstructorWillBe.Ignored)
 
    ' the following call does not return a value so it is simply ignored
    fake.Increment()
 
    ' the following call did not have its behavior set so it will throw when called
    fake.GetFile()
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members,Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe,System.Object[])">
 <summary>
 Returns a fake instance of type T.
 </summary>
 <typeparam name="T">The type of fake object to create.</typeparam>
 <param name="behavior">The default behavior the fake object will use, see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.Members"/> for possible values.</param>
 <param name="constructorBehavior">Declare if the class constructor should execute, see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe"/> for possible values.</param>
 <param name="constructorParameters">The parameters to pass to a specific constructor. 
 If <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe.Ignored"/> is used an <see cref="T:TypeMock.TypeMockException"/> will be thrown</param>
 <returns>A fake instance of Type T.</returns>
 <example>
 The following test shows creating a fake instance with the default value of <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnRecursiveFakes"/>:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_UseDefault()
    ' Create a fake object which will return recursive fakes but call the class constructor with a specific an argument
    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.ReturnRecursiveFakes, ConstructorWillBe.Called, "c:\log")
 
    ' This fake object will now return zero or equivalent to methods returning value types
    Assert.AreEqual(0, fake.CountLines)
 
    ' It will return recursive fakes for functions returning reference types, so deep calls
    ' will not return null values
    Assert.IsNotNull(fake.LogFile.ContainingFolder)
 End Sub
 </code>
 The next test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.CallOriginal"/> to create a fake object that will behave 
 identically to a normal object, but can still have its behavior modified or asserted against:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_CallOriginal
    ' Create a fake object and call the class constructor with a specific an argument
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal, ConstructorWillBe.Called, "c:\log")
 
    fake.LineCount = 0
    ' The following call is not faked so the original implementation will be executed
    fake.Write("Hello")
 
    Assert.AreEqual(1, fake.LineCount)
 End Sub 
 </code>
 The next test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.ReturnNulls"/> to create a fake object that will return null values
 (Nothing) for any function returning a reference type, and 0 or equivalent for functions returning a value type:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_ReturnNulls()
    ' Create a fake object and call the class constructor with a specific an argument
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.ReturnNulls, ConstructorWillBe.Called, "c:\log")
 
    ' The fake object will return Nothing for any call returning a reference type
    Assert.IsNull(fake.LogFile)
    ' It will return 0 for any calls returning a value type
    Assert.AreEqual(0, fake.LineCount)
 End Sub
 </code>
 The final test shows using <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.Members.MustSpecifyReturnValues"/> to ruturn a fake object that will 
 throw an exception if no behavior is set on a function it called:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeInstance_MustSpecifyReturnValues()
    ' Create a fake object and call the class constructor with a specific an argument
    Dim fake as RealLogger = FakeInstance(Of RealLogger)(Members.MustSpecifyReturnValues, ConstructorWillBe.Called, "c:\log")
 
    ' the following call does not return a value so it is simply ignored
    fake.Increment()
 
    ' the following call did not have its behavior set so it will throw when called
    fake.GetFile()
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members,Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe,Typemock.Isolator.VisualBasic.IsolateVB.BaseConstructorWillBe)">
 <summary>
 Overloaded. Returns a fake instance of type T.
 </summary>
 <remarks>
 </remarks>
 <typeparam name="T">The type of the fake instance to be created.</typeparam>
 <param name="behavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>Members</c> Value</term><description>Description</description></listheader>
 <item>
 <term><c>Members.MustSpecifyReturnValues</c></term>
 <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnNulls</c></term>
 <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
 </description>
 </item>
 <item>
 <term><c>Members.CallOriginal</c></term>
 <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnRecursiveFakes</c></term>
 <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
 </description>
 </item>
 </list>
 </param>
 <param name="constructorBehavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
 </listheader>
 <item>
 <term><c>ConstructorWillBe.Ignored</c></term>
 <description>Constructor will not be executed when creating the fake object</description>
 </item>
 <item>
 <term><c>ConstructorWillBe.Called</c></term>
 <description>Execute Constructor when creating the fake object</description>
 </item>
 </list>
 </param>
 <param name="baseConstructorBehavior">
 Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
 when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
 </param>
 <returns>A fake instance of Type T.</returns>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking a base class constructor for a type that inherits directly from System.Object (or other mscorlib types)
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
 </exception>
 <seealso cref="T:TypeMock.TypeMockException"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedConstructor``1" />
 <example>
 The following test shows faking an instance without calling its base class&apos; constructor
 <code lang="vbnet">
 &lt;TestMethod(), Isolated()&gt;
 Public Sub FakeAnInstance_DoNotCallBaseCtor()
     &apos; create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
     Dim fake As RealLogger = FakeInstance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, _
                                                             ConstructorWillBe.Called, _
                                                             BaseConstructorWillBe.Ignored)
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members,Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe,Typemock.Isolator.VisualBasic.IsolateVB.BaseConstructorWillBe,System.Object[])">
 <summary>
 Overloaded. Returns a fake instance of type T.
 </summary>
 <remarks>
 </remarks>
 <typeparam name="T">The type of the fake instance to be created.</typeparam>
 <param name="behavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>Members</c> Value</term><description>Description</description></listheader>
 <item>
 <term><c>Members.MustSpecifyReturnValues</c></term>
 <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnNulls</c></term>
 <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
 </description>
 </item>
 <item>
 <term><c>Members.CallOriginal</c></term>
 <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnRecursiveFakes</c></term>
 <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
 </description>
 </item>
 </list>
 </param>
 <param name="constructorBehavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
 </listheader>
 <item>
 <term><c>ConstructorWillBe.Ignored</c></term>
 <description>Constructor will not be executed when creating the fake object</description>
 </item>
 <item>
 <term><c>ConstructorWillBe.Called</c></term>
 <description>Execute Constructor when creating the fake object</description>
 </item>
 </list>
 </param>
 <param name="baseConstructorBehavior">
 Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
 when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
 </param>
 <param name="constructorArguments">        
 The parameters to pass to a specific constructor. 
 </param>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if <paramref name="constructorBehavior"/> is set to <see cref="F:Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe.Ignored"/> and parameter arguments are passed in <paramref name="constructorArguments"/>
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments"/>
 </exception>
 <returns>A fake instance of Type T.</returns>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedConstructor``1"/>
 <example>
 The following test shows faking an instance without calling its base class&apos; constructor
 <code lang="vbnet">
 &lt;TestMethod(), Isolated()&gt;
 Public Sub FakeAnInstance_DoNotCallBaseCtor()
     &apos; create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
     Dim fake As RealLogger = FakeInstance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, _
                                                             ConstructorWillBe.Called, _
                                                             BaseConstructorWillBe.Ignored, _
                                                             "C:\\log.txt")
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members,Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe,Typemock.Isolator.VisualBasic.IsolateVB.BaseConstructorWillBe,System.Type)">
 <summary>
 Overloaded. Returns a fake instance of type T.
 </summary>
 <typeparam name="T">
 The type of the fake instance to be created. T can only be a reference type - 
 to fake structs use an overload that does not define base constructor behavior
 </typeparam>
 <param name="behavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>Members</c> Value</term><description>Description</description></listheader>
 <item>
 <term><c>Members.MustSpecifyReturnValues</c></term>
 <description>
 All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> 
 on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnNulls</c></term>
 <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
 </description>
 </item>
 <item>
 <term><c>Members.CallOriginal</c></term>
 <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnRecursiveFakes</c></term>
 <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
 </description>
 </item>
 </list>
 </param>
 <param name="constructorBehavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
 </listheader>
 <item>
 <term><c>ConstructorWillBe.Ignored</c></term>
 <description>Constructor will not be executed when creating the fake object</description>
 </item>
 <item>
 <term><c>ConstructorWillBe.Called</c></term>
 <description>Execute Constructor when creating the fake object</description>
 </item>
 </list>
 </param>
 <param name="baseConstructorBehavior">
 Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
 when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
 </param>
 <param name="baseTypeToIgnoreConstructor">
 The type of the base class who&apos;s constructor will be ignored.
 </param>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor"/>
 </exception>
 <returns>A fake instance of Type T.</returns>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedConstructor``1" />
 <example>
 The following test shows faking an instance without calling its base class&apos; constructor
 <code>
 &lt;TestMethod(), Isolated()&gt;
 Public Sub FakeAnInstance_DoNotCallBaseCtor()
     &apos; create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
     Dim fake As RealLogger = FakeInstance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, _
                                                             ConstructorWillBe.Called, _
                                                             BaseConstructorWillBe.Ignored, _
                                                             GetType(AbstractLoggerBase));
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members,Typemock.Isolator.VisualBasic.IsolateVB.ConstructorWillBe,Typemock.Isolator.VisualBasic.IsolateVB.BaseConstructorWillBe,System.Type,System.Object[])">
 <summary>
 Overloaded. Returns a fake instance of type T.
 </summary>
 <typeparam name="T">
 The type of the fake instance to be created. T can only be a reference type - 
 to fake structs use an overload that does not define base constructor behavior
 </typeparam>
 <param name="behavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>Members</c> Value</term><description>Description</description></listheader>
 <item>
 <term><c>Members.MustSpecifyReturnValues</c></term>
 <description>
 All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> 
 on methods that return values and properties, they will throw a <seealso cref="T:TypeMock.TypeMockException"/>.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnNulls</c></term>
 <description>All void calls are ignored. Unless using <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> on methods that return values and properties, they will return null values (or zero for value types).
 </description>
 </item>
 <item>
 <term><c>Members.CallOriginal</c></term>
 <description>All methods are called. Use <see cref="M:TypeMock.ArrangeActAssert.Isolate.WhenCalled(System.Action)"/> to change this behavior.
 </description>
 </item>
 <item>
 <term><c>Members.ReturnRecursiveFakes</c></term>
 <description>Default. All void calls are ignored. When calling the fake's methods returning values or properties, they will return a fake value, which presents this behavior recursively. Any deep call will never return a Null value.
 </description>
 </item>
 </list>
 </param>
 <param name="constructorBehavior">
 Can be one of the following values:
 <list type="table">
 <listheader>
 <term><c>ConstructorWillBe</c> Value</term><description>Description</description>
 </listheader>
 <item>
 <term><c>ConstructorWillBe.Ignored</c></term>
 <description>Constructor will not be executed when creating the fake object</description>
 </item>
 <item>
 <term><c>ConstructorWillBe.Called</c></term>
 <description>Execute Constructor when creating the fake object</description>
 </item>
 </list>
 </param>
 <param name="baseConstructorBehavior">
 Can receive BaseConstructorWillBe.Ignored. Means that the constructor of the base class will not be called
 when creating the fake object. Applicable only when <paramref name="constructorBehavior"/> is <c>ConstructorWillBe.Called</c>
 </param>
 <param name="baseTypeToIgnoreConstructor">
 The type of the base class who&apos;s constructor will be ignored.
 </param>
 <param name="constructorArguments">        
 The parameters to pass to a specific constructor. 
 </param>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking a base class constructor for a type that inherits directly from System.Object or other mscorlib types
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if faking an interface - to fake an interface use an overload that does not define base class behavior
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if the type being faked does not inherit from <paramref name="baseTypeToIgnoreConstructor"/>
 </exception>
 <exception cref="T:TypeMock.TypeMockException">
 Thrown if there is no constructor that will take the argument set defined in <paramref name="constructorArguments"/>
 </exception>
 <returns>A fake instance of Type T.</returns>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedConstructor``1" />
 <example>
 The following test shows faking an instance without calling its base class&apos; constructor
 <code>
 &lt;TestMethod(), Isolated()&gt;
 public void FakeAnInstance_DoNotCallBaseCtor()
 {
     &apos; create a fake of RealLogger, calling the RealLogger constructor but not its base class c&apos;tor
     Dim fake as RealLogger = FakeInstance&lt;RealLogger&gt;(Members.ReturnRecursiveFakes, _
                                                             ConstructorWillBe.Called, _
                                                             BaseConstructorWillBe.Ignored, _
                                                             GetType(AbstractLoggerBase));
 }
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedConstructor``1">
 <summary>
 Fake future calls to shared constructors of the given type. 
 </summary>
 <typeparam name="T">The type for which to fake shared constructor calls</typeparam>
 <example>
 This example shows using FakeSharedConstructor to prevent a shared constructor from being called:
 &lt;TestMethod()&gt; Public Sub FakeSharedConstructor_CCtorNotCalled()
    FakeSharedConstructor(Of TestClass)()
 
    TestClass.DoSomething() ' calling a shared method causes the shared constructor to be invoked
 
    ' The call to the shared constructor was faked so the flag equals false   
    Assert.IsFalse(TestClass.TrueIfCCtorHappened)
 End Sub
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedMethods``1(Typemock.Isolator.VisualBasic.IsolateVB.Members)">
 <summary>
 Fakes all shared methods for the given type. 
 </summary>
 <typeparam name="T">The type to fake shared methods of</typeparam>
 <param name="behavior">A default behavior for the type's shared methods, see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.Members"/></param>
 <example>
 The following example shows using FakeSharedMethods to fake a module's methods:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeSharedMethods_OnModule()
    FakeSharedMethods(GetType(LoggerFactory), Members.ReturnRecursiveFakes)
 
    ' the fake object will now return recursive fakes:
    Assert.IsNotNull(fake.GetLogger().LogFile)
 End Sub
 </code>
 This is very similar to fake an instance's methods. For more example usages see <see cref="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeInstance``1(Typemock.Isolator.VisualBasic.IsolateVB.Members)"/>.
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.FakeSharedMethods(System.Type,Typemock.Isolator.VisualBasic.IsolateVB.Members)">
 <summary>
 Fakes all shared methods for the given type. 
 </summary>
 <param name="type">The type to fake shared methods of</param>
 <param name="behavior">A default behavior for the type's shared methods, see <see cref="T:Typemock.Isolator.VisualBasic.IsolateVB.Members"/></param>
 <remarks>
 This overload receives a Type parameter representing the class to fake shared methods for, and should be used when 
 faking methods for modules. For other non-shared classes it is generally recommended to use the generic overload 
 for this method which receives the class as a generic type argument. </remarks>
 <example>
 The following example shows using FakeSharedMethods to fake a module's methods:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub FakeSharedMethods_OnModule()
    FakeSharedMethods(GetType(LoggerFactory), Members.ReturnRecursiveFakes)
 
    ' the fake object will now return recursive fakes:
    Assert.IsNotNull(fake.GetLogger().LogFile)
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.SwapNextInstance``1(``0)">
 <summary>
 Specify that the next instance created for type T will be swapped with the provided object
 </summary>
 <typeparam name="T">The type to replace the next instance of</typeparam>
 <param name="obj">The object to return next time T is instantiated</param>
 <example>
 The next test shows using SwapNextInstance to replace a future instance with a faked one:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub SwapNextInstance_ReplaceFutureObject()
    ' create a fake logger
    Dim fake as RealLogger = FakeInstance(Of RealLogger)()
 
    ' the next time a RealLogger is instantiated return the fake logger above:
    SwapNextInstance(Of RealLogger)(fake)
 
    Dim logger As ILogger = LoggerFactory.GetRealLogger()
    Assert.AreEqual(0, fake.LineCount)
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.SwapAllInstances``1(``0)">
 <summary>
 Specify that all instances created for type T will be swapped with the provided object.
 The behavior that is defined for the faked object will be applied to all past and future instances of the type.
 </summary>
 <typeparam name="T">The type to replace the instances of</typeparam>
 <param name="obj">The object that its behavior will be applied to all instances of the type</param>
 <example>
 The next test shows using SwapAllInstances to replace two future instances with a faked one:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub SwapAllInstances_FakeTwoFutureInstance_BothAreFaked()
     Dim fake As RealLogger = FakeInstance(Of RealLogger)()  
     SwapAllInstances(Of RealLogger)(fake)
     
     ' here we define a behavior that will be applied to all instances of RealLogger
     Using TheseCalls.WillReturn(100)
         fake.ReturnFive()
     End Using
     
     Dim real1 As RealLogger = New RealLogger()
     Dim real2 As RealLogger = New RealLogger()
     
     Assert.AreEqual(100, real1.ReturnFive())
     Assert.AreEqual(100, real2.ReturnFive())
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.SwapAllInstancesWithException``1(System.Exception)">
 <summary>
 Specify that an exception will be thrown every time a construction is encountered for the type 
 </summary>
 <typeparam name="T">The type to replace next instantiation of with an exception</typeparam>
 <param name="exceptionToThrow">The exception that will be thrown when the constructor is called</param>
 <example>
 This test shows how to cause a type to throw an exception every time it's instantiated:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub SwapAllInstancesWithException_TwoFutureInstances_AllConstructorsThrows()
    ' Simulate an out of memory exception each time creating a RealLogger
    SwapAllInstancesWithException(Of RealLogger)(New OutOfMemoryException())
    Dim logger As RealLogger
    
    Try
        logger = New RealLogger()
        Assert.Fail("should throw an exception")
    Catch ex As OutOfMemoryException
    
    End Try
    
    Try
        logger = New RealLogger()
        Assert.Fail("should throw an exception")
    Catch ex As OutOfMemoryException
    
    End Try
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.SwapNextInstanceWithException``1(System.Exception)">
 <summary>
 Specify that an exception will be thrown the next time a construction is encountered for the type 
 </summary>
 <typeparam name="T">The type to replace next instantiation of with an exception</typeparam>
 <param name="exceptionToThrow">The exception that will be thrown when the constructor is called</param>
 <example>
 This test shows how to cause a type to throw an exception when instantiated:
 <code lang="vbnet">
 &lt;TestMethod()&gt; Public Sub SwapNextInstanceWithException_SimulateConstructorException()
    ' Simulate an out of memory exception when creating a RealLogger
    SwapNextInstanceWithException(Of RealLogger)(New OutOfMemoryException())
 
    ' The factory method should handle the exception by returning Nothing
    Assert.IsNull(LoggerFactory.GetRealLogger())
 End Sub
 </code>
 </example>
</member>
<member name="T:Typemock.Isolator.VisualBasic.IsolateVB.ReplaceFunction`2">
 <summary>
 Custom delegate that will run instead of a function in the code under test.
 </summary>
 <typeparam name="TResult">Type of the object returned from the function</typeparam>
 <param name="arg">Argument passed to the function <see cref="T:TypeMock.MethodCallContext"/></param>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.NonPublicWillBeReplacedWith(System.Object,System.String,Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="T:Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction`1">
 <summary>
 Custom delegate that will run instead of a action (Sub) in the code under test.
 </summary>
 <param name="arg">Argument passed to the function <see cref="T:TypeMock.MethodCallContext"/></param>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.IsolateVB.NonPublicWillBeReplacedWith(System.Object,System.String,Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.IsolateVB.RedirectCalls(System.Object,System.Object)">
 <summary>
 Enables redirecting any calls made on the source object with calls implemented on the target object
 </summary>
 <param name="source">The object to swap implementation for</param>
 <param name="target">The object to use implementation from</param>
 <remarks>When a method is called on the source object, it is replaced with a corresponding implementation 
 (a method with the same signature) on the target object. This means that the source object will start 
 behaving like the object it was redirected to for all methods they have in common.</remarks>
 <example>
 This example shows using RedirectCalls() to redirect calls from an object to a stand in:
 <code lang="vbnet">
 &lt;TestMethod()&gt; 
 &lt;Isolated()&gt; 
 Public Sub RedirectCalls_CallsRedirectedToTargetObject()
    ' Create the object under test
    Dim logger As New RealLogger 
    ' Create the object calls will be redirected to
    Dim standIn As New TestLogger 
 
    ' Redirect any calls from the object under test to the stand in
    RedirectCalls(logger, standIn)
 
    ' logger.Write() is redirected to TestLogger.Write() which writes to console instead of disk
    logger.Write("Hello World");

    ' We can still verify the call to logger.Write() happened
    Using AssertCalls.HappenedWithAnyArguments()
       logger.Write("")
    End Using
 End Sub
 
 ' excerpt code for the class under test:
 Public Class RealLogger
    Dim logFilePath As String = ...
    Public Sub Write(ByVal toWrite As String)
       logFile.WriteAllText(logFilePath, toWrite)
    End Sub
 End Class

 ' excerpt code for the stand-in class:
 Public Class TestLogger
 
    Public Sub Write(ByVal toWrite As String)
       Console.WriteLine("RealLogger.Write() was called with " &amp; toWrite)
    End Sub
 End Class
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillBeIgnored">
 <summary>
 The calls in the Using block will not be executed
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <exception cref="T:TypeMock.TypeMockException">Thrown if a Function is used in the Using block (cannot ignore a Function, must set some return value).</exception>
 <example>
 This example shows using TheseCalls.WillBeIgnored() to avoid executing a Sub:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_IgnoreSub()
    ' Create a fake object that by default behaves like a real object
    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)
    
    ' Ignore the Increment() method
    Using TheseCalls.WillBeIgnored()
       fake.Increment()
    End Using
 
    fake.Increment()
 
    ' The call did not really happen and the count was not incremented
    Assert.AreEqual(0, fake.count)
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillCallOriginal">
 <summary>
 Specify that when the calls in the using block are called, their original implementation will be used.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillCallOriginal() to execute an original implementation on a fake object:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_CallOriginal()
    ' Create a fake object that by default ignores subs
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
    
    ' State that the original implementation of Increment() will be called
    Using TheseCalls.WillCallOriginal()
       fake.Increment()
    End Using
 
    fake.Increment()
 
    ' Increment() called its original implementation which increments a counter
    Assert.AreEqual(1, fake.count)
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillReturn(System.Object)">
 <summary>
 Specify a return value that will be returned when the functions in the using block are called.
 </summary>
 <exception cref="T:TypeMock.TypeMockException">Thrown if a Sub is used in the Using block (cannot set a return value on a Sub)</exception>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillReturn() to execute an original implementation on a fake object:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_DefineReturnValue()
    ' Create a fake object
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
    
    ' Define a return value for GetLineCount()
    Using TheseCalls.WillReturn(5)
       fake.GetLineCount()
    End Using
 
    Assert.AreEqual(5, fake.GetLineCount())
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillThrow(System.Exception)">
 <summary>
 Specify that when methods in the Using block are called they will throw the specified exception.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillThrow() to simulate an exception thrown from a method call:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_ThrowException()
    ' Define that when a factory method is called, a memory exception is simulated
    Using TheseCalls.WillThrow(New OutOfMemoryException())
       LoggerFactory.GetLogger()
    End Using
 
    ' This call will throw the exception:
    Dim logger As RealLogger = LoggerFactory.GetLogger()
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillReturnRecursiveFake">
 <summary>
 Specify that when methods in the Using block are called they will return a faked object or default(T) for value types.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillReturnRecursiveFake():
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_WillReturnRecursiveFake()
    ' Define that when a factory method is called, a fake logger will be returned
    Using TheseCalls.WillReturnRecursiveFake()
       LoggerFactory.GetLogger()
    End Using
 
    ' This call return a fake Logger:
    Dim logger As RealLogger = LoggerFactory.GetLogger()
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})">
 <summary>
 Run a custom function instead of the methods in the Using block.
 </summary>
 <param name="actionToUse">The method that will replace the code used</param>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows usage of TheseCalls.WillReturnRecursiveFake():
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_WillBeReplacedWith()

    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)

    ' Define that when the ReturnFive method is called, RunInstead will be run
    Using TheseCalls.WillBeReplacedWith(AddressOf RunInstead)
        fake.VoidCall()
    End Using

    fake.VoidCall()
 
    Assert.AreEqual(10, fake.count)
 End Sub
 
 public Sub RunInstead(ByVal callContext As MethodCallContext)
     CType(MethodCallContext.Instance, RealLogger).count = 10
 Sub Function
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCallsInstance.WillBeReplacedWith``1(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceFunction{TypeMock.MethodCallContext,``0})">
 <summary>
 Run a custom action instead of the methods in the Using block.
 </summary>
 <typeparam name="T">Type of the value returned from the methohd</typeparam>
 <param name="funcToUse">The method that will replace the code used</param>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillReturnRecursiveFake():
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_WillBeReplacedWith()

    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)

    ' Define that when the ReturnFive method is called, RunInstead will be run
    Using TheseCalls.WillBeReplacedWith(AddressOf RunInstead)
        fake.ReturnFive()
    End Using

    Dim result As Integer = fake.ReturnFive()

    Assert.AreEqual(10, result)
 End Sub
 
 public Function RunInstead(ByVal callContext As MethodCallContext) As Integer
     return 10
 End Function
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="T:Typemock.Isolator.VisualBasic.TheseCalls">
 <summary>
 This class is the entry point for setting behavior on functions and subs. The supported behaviors
 are:
 <list type="table">
 <listheader><term>Behavior</term><description>Description</description></listheader>
 <item><term>TheseCalls.WillReturn</term><description>The calls in the using block will return the specified value. Applies only to Functions.</description></item>
 <item><term>TheseCalls.WillCallOriginal</term><description>The original implementation of the calls in the using block will be used.</description></item>
 <item><term>TheseCalls.WillThrow</term><description>When a call in the using block is called, it will throw the provided exception.</description></item>
 <item><term>TheseCalls.WillBeIgnored</term><description>The calls in the using block will not be executed. Applies only to Subs.</description></item>
 </list>
 </summary>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WithExactArguments">
 <summary>
 Specifies that the behavior will only be set on method calls with the exact arguments.
 </summary>
 <remarks>
 <para>
 WithExactArguments() is a completing statement for <see cref="T:Typemock.Isolator.VisualBasic.TheseCalls"/>. 
 </para>
 </remarks>
 <example>
 This example shows how to use WithExactArguments() to set behavior on specific method call
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_DefineReturnValue()
    ' Create a fake object
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
    
    ' Define a return value for function that return int
    Using TheseCalls.WillReturn(10)
       fake.IntCallWithArg(0)
    End Using
 
    Using TheseCalls.WillReturn(20)
       fake.IntCallWithArg(1)
    End Using
 
    ' Verify return values
    Assert.AreEqual(10, fake.IntCallWithArg(0));
    Assert.AreEqual(20, fake.IntCallWithArg(1));
 End Sub
 </code>
 </example>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored">
 <summary>
 The calls in the Using block will not be executed
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <exception cref="T:TypeMock.TypeMockException">Thrown if a Function is used in the Using block (cannot ignore a Function, must set some return value).</exception>
 <example>
 This example shows using TheseCalls.WillBeIgnored() to avoid executing a Sub:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_IgnoreSub()
    ' Create a fake object that by default behaves like a real object
    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)
    
    ' Ignore the Increment() method
    Using TheseCalls.WillBeIgnored()
       fake.Increment()
    End Using
 
    fake.Increment()
 
    ' The call did not really happen and the count was not incremented
    Assert.AreEqual(0, fake.count)
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal">
 <summary>
 Specify that when the calls in the using block are called, their original implementation will be used.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillCallOriginal() to execute an original implementation on a fake object:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_CallOriginal()
    ' Create a fake object that by default ignores subs
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
    
    ' State that the original implementation of Increment() will be called
    Using TheseCalls.WillCallOriginal()
       fake.Increment()
    End Using
 
    fake.Increment()
 
    ' Increment() called its original implementation which increments a counter
    Assert.AreEqual(1, fake.count)
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)">
 <summary>
 Specify a return value that will be returned when the functions in the using block are called.
 </summary>
 <exception cref="T:TypeMock.TypeMockException">Thrown if a Sub is used in the Using block (cannot set a return value on a Sub)</exception>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillReturn() to execute an original implementation on a fake object:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_DefineReturnValue()
    ' Create a fake object
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
    
    ' Define a return value for GetLineCount()
    Using TheseCalls.WillReturn(5)
       fake.GetLineCount()
    End Using
 
    Assert.AreEqual(5, fake.GetLineCount())
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)">
 <summary>
 Specify that when methods in the Using block are called they will throw the specified exception.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillThrow() to simulate an exception thrown from a method call:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_ThrowException()
    ' Define that when a factory method is called, a memory exception is simulated
    Using TheseCalls.WillThrow(New OutOfMemoryException())
       LoggerFactory.GetLogger()
    End Using
 
    ' This call will throw the exception:
    Dim logger As RealLogger = LoggerFactory.GetLogger()
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturnRecursiveFake">
 <summary>
 Specify that when methods in the Using block are called they will return a faked object or default(T) for value types.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillReturnRecursiveFake():
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_WillReturnRecursiveFake()
    ' Define that when a factory method is called, a fake logger will be returned
    Using TheseCalls.WillReturnRecursiveFake()
       LoggerFactory.GetLogger()
    End Using
 
    ' This call return a fake Logger:
    Dim logger As RealLogger = LoggerFactory.GetLogger()
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith``1(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceFunction{TypeMock.MethodCallContext,``0})">
 <summary>
 Specify that when methods in the Using block are called they will run a custom function insead.
 </summary>
 <typeparam name="T">Type of the value returned from the methohd</typeparam>
 <param name="funcToUse">The method that will replace the code used</param>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows using TheseCalls.WillReturnRecursiveFake():
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_WillBeReplacedWith()

    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)

    ' Define that when the ReturnFive method is called, RunInstead will be run
    Using TheseCalls.WillBeReplacedWith(AddressOf RunInstead)
        fake.ReturnFive()
    End Using

    Dim result As Integer = fake.ReturnFive()

    Assert.AreEqual(10, result)
 End Sub
 
 public Function RunInstead(ByVal callContext As MethodCallContext) As Integer
     return 10
 End Function
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})">
 <summary>
 Specify that when methods in the Using block are called they will run a custom function insead.
 </summary>
 <param name="actionToUse">The method that will replace the code used</param>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <example>
 This example shows usage of TheseCalls.WillReturnRecursiveFake():
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub SetCallBehavior_WillBeReplacedWith()

    Dim fake As RealLogger = FakeInstance(Of RealLogger)(Members.CallOriginal)

    ' Define that when the ReturnFive method is called, RunInstead will be run
    Using TheseCalls.WillBeReplacedWith(AddressOf RunInstead)
        fake.VoidCall()
    End Using

    fake.VoidCall()
 
    Assert.AreEqual(10, fake.count)
 End Sub
 
 public Sub RunInstead(ByVal callContext As MethodCallContext)
     CType(MethodCallContext.Instance, RealLogger).count = 10
 Sub Function
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeIgnored"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillCallOriginal"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillReturn(System.Object)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillThrow(System.Exception)"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.TheseCalls.WillBeReplacedWith(Typemock.Isolator.VisualBasic.IsolateVB.ReplaceAction{TypeMock.MethodCallContext})"/>
</member>
<member name="T:Typemock.Isolator.VisualBasic.AssertCalls">
 <summary>
 This class is the entry point for asserting behavior correctness for on functions and subs. The supported assertions
 are:
 <list type="table">
 <listheader><term>Assertion</term><description>Description</description></listheader>
 <item><term>AssertCalls.HappenedWithAnyArguments</term><description>Assert that the calls in the Using block happened, regardless of arguments.</description></item>
 <item><term>AssertCalls.HappenedWithExactArguments</term><description>Assert that the calls happened with the exact arguments specified in the Using block.</description></item>
 <item><term>AssertCalls.NeverHappened</term><description>Assert that the calls in the Using block did not happen.</description></item>
 </list>
 </summary>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithAnyArguments"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithExactArguments"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.NeverHappened"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithAnyArguments">
 <summary>
 Assert that the calls in the Using block were actually called, regardless of arguments.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <exception cref="T:TypeMock.VerifyException">Thrown if a call in the Using block was not called.</exception>
 <example>
 This example shows using AssertCalls.HappenedWithAnyArguments to verify a call has been made:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub AssertCalls_VerifyCallsHappened()
    ' Create a fake object 
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
 
    fake.Write("Hello World")
 
    ' Assert that the Write() call happened
    Using AssertCalls.HappenedWithAnyArguments
       fake.Write("") ' the arguments here are not verified
    End Using
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithExactArguments"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.NeverHappened"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithExactArguments">
 <summary>
 Assert that the calls in the Using block were actually called with the exact arguments specified in the Using block.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <exception cref="T:TypeMock.VerifyException">Thrown if a call in the Using block was not called, or if it was not
 called with the specified arguments.</exception>
 <example>
 This example shows using AssertCalls.HappenedWithExactArguments() to verify a call has been made:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub AssertCalls_VerifyCallsHappenedWithArguments()
    ' Create a fake object 
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
 
    fake.Write("Hello World")
 
    ' Assert that the Write() call happened with the correct arguments
    Using AssertCalls.HappenedWithExactArguments
       fake.Write("Hello World") ' the arguments here are verified
    End Using
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithAnyArguments"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.NeverHappened"/>
</member>
<member name="M:Typemock.Isolator.VisualBasic.AssertCalls.NeverHappened">
 <summary>
 Assert that the calls in the Using block did not happen.
 </summary>
 <remarks>This statement should be used as part of a Using block (see example below).</remarks>
 <exception cref="T:TypeMock.VerifyException">Thrown if a call in the Using block was called</exception>
 <example>
 This example shows using AssertCalls.NeverHappened() to verify a call has not been made:
 <code lang="vbnet">
 &lt;TestMethod()&gt; _
 &lt;Isolated()&gt; Public Sub AssertCalls_VerifyCallDidNotHappen()
    ' Create a fake object 
    Dim fake As RealLogger = FakeInstance(Of RealLogger)()
 
    fake.Increment()
 
    ' Assert that the Write() call did not happen
    Using AssertCalls.NeverHappened()
       fake.Write("")
    End Using
 End Sub
 </code>
 </example>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithAnyArguments"/>
 <seealso cref="M:Typemock.Isolator.VisualBasic.AssertCalls.HappenedWithExactArguments"/>
</member>
</members>
</doc>
